% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/read-fasta.R
\name{read_fasta}
\alias{read_fasta}
\title{Read sequences from a fasta file.}
\usage{
read_fasta(file, per_line = FALSE, unalign = FALSE)
}
\arguments{
\item{file}{string. Path to the fasta file.}

\item{per_line}{logical scalar. Whether sequences keep in one line or might
span multiple lines. Specify \code{FALSE} if not sure, refer to \strong{Details}.}

\item{unalign}{logical scalar. Whether unalign aligned sequences, i.e. remove
'-', see \strong{Details}.}
}
\value{
tibble
\itemize{
\item name: character. sequence header (without '>')
\item seq:  character. sequence itself, I named it \code{seq} instead of \code{sequence} to
save 62.5\% of time (and everyone using R should take it for granted that seq
means sequence)
}
}
\description{
\code{read_fasta()} reads all sequences contained in a fasta file
into a tibble (see \strong{Value}). See \emph{FASTA format} for the requirements of
input file.
}
\details{
Previously, I implemented fasta as a named character
(\code{bioinfor::read_fasta()}). But I found it more and more inconvenient as I
used it. Many times when you manipulate the character, the name got lost.
Finally, I decided to reimplement it as a tibble. That why this package
come into being.

Actually, \code{file} can be anything as long as it's recognized by
\code{\link[readr:read_lines]{readr::read_lines()}}.

If \code{per_line} isn't \code{TRUE}, \code{read_fasta()} will check it by detecting '>'
and count line number. This (implemented by \code{\link[stringr:str_detect]{stringr::str_detect()}}) takes
almost the same time as reading file content (implemented by
\code{\link[readr:read_lines]{readr::read_lines()}}). So specify \code{TRUE} if you are sure to save time. But
this checking doesn't waste any time when sequences indeed span multiple
lines. Additionly, a file contains odd number of lines will cause
\code{pre_line=TURE} to be ignored

For \code{unalign}, when deal with large aligned file with linebreak containing
many '-'s, implement \emph{unalign} (\code{\link[stringr:str_replace]{stringr::str_replace_all()}} in
\code{\link[=read_fasta]{read_fasta()}}) is about 15\% faster than do that externally, i.e. after
\code{\link[=read_fasta]{read_fasta()}} returns.
}
\section{FASTA format}{
 The minimum requirement is that it can only contain
sequences (can use any character except for '>', at least at the begining)
and their headers (begin with '>', one line). Comments are not supported.

Basically, \code{c('>na', 'me', 'ATCG')} (name span two lines) and \code{c('>name', '>ATCG')} (sequence begins with '>') are most common (and maybe the only)
errors. Expect that, almost anything is acceptable (though your file may
not be recongnized by other program):
\enumerate{
\item name contains '>', see crazy example 1.
\item sequence contains '>' (can't be at the begining), see crazy example 2.
\item empty name, see crazy example 3.
\item empty sequence, see crazy example 4. But it must occupy an empty line if
you want to scape check for \code{pre_line} (refer to details).
\item very long name, see crazy example 5. It can contain thousands of
thousands characters, so long as you have enough memory (and disk if you
are really mad).
\item don't you think the above is enough? We can't make friends anymore.
(Never tell me you have tried crazy example 6)
}

In most situations, you won't have a file like that, unless you
deliberately create one.
}

\section{Test files}{

\enumerate{
\item test1.fasta big file with linebreak.
\item test12.fasta same file without.
\item test2.fasta big aligned file with linebreak.
}
}

\examples{
system.file('extdata', 'example.fasta', package = 'rutil') |> read_fasta()

system.file('extdata', 'aligned-multiline.fasta', package = 'rutil') |> read_fasta()

system.file('extdata', 'aligned-multiline.fasta', package = 'rutil') |> read_fasta(unalign = TRUE)


# crazy examples
read_fasta('>na>me\nATCG')

read_fasta('>name\nAT>CG')

read_fasta('>\nATCG')

read_fasta('>name\n')

read_fasta(paste0(c('>', rep('x', 10000), '\nATCG'), collapse = ''))

read_fasta(I('>name'))

}
